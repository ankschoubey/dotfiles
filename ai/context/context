#!/bin/bash

# Color Codes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Get the absolute path of the script's directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" &> /dev/null && pwd)"

# Use the script's directory as the base for the storage path
STORAGE_PATH="$SCRIPT_DIR/../../../.aerospace-context"
TASKS_STORAGE_PATH="$STORAGE_PATH/tasks"

# Ensure the storage directories exist
if [ ! -d "$STORAGE_PATH" ]; then
  mkdir -p "$STORAGE_PATH"
fi
if [ ! -d "$TASKS_STORAGE_PATH" ]; then
  mkdir -p "$TASKS_STORAGE_PATH"
fi

# Function to get the current workspace name
get_workspace_name() {
  aerospace list-workspaces --focused
}

# Function to set the name for the current workspace
set_workspace_name() {
  local workspace_name="$1"
  local current_workspace=$(get_workspace_name)
  echo "$workspace_name" > "$STORAGE_PATH/$current_workspace"
}

# Function to get the name of the current workspace
get_current_workspace_name() {
  local current_workspace=$(get_workspace_name)
  if [ -f "$STORAGE_PATH/$current_workspace" ]; then
    cat "$STORAGE_PATH/$current_workspace"
  else
    echo "(unnamed)"
  fi
}

# Function to clear the name for the current workspace
clear_workspace_name() {
  local current_workspace=$(get_workspace_name)
  if [ -f "$STORAGE_PATH/$current_workspace" ]; then
    rm "$STORAGE_PATH/$current_workspace"
  fi
}

# Function to list all saved contexts
list_all_contexts() {
  local contexts_list=""
  for file in "$STORAGE_PATH"/*; do
    if [ -f "$file" ]; then
      local workspace_id=$(basename "$file")
      local custom_name=$(cat "$file")
      contexts_list+="$workspace_id $custom_name\n"
    fi
  done

  if [ -n "$contexts_list" ]; then
    local selected_context=$(echo -e "$contexts_list" | fzf --with-nth=2.. --delimiter=' ')
    if [ -n "$selected_context" ]; then
      local selected_workspace_id=$(echo "$selected_context" | awk '{print $1}')
      aerospace workspace "$selected_workspace_id"
    fi
  else
    echo "No contexts saved." >&2
  fi
}

# --- Task Management Functions ---

# Helper to get the task file path for the current workspace
_get_task_file_path() {
  local current_workspace=$(get_workspace_name)
  echo "$TASKS_STORAGE_PATH/$current_workspace.tasks"
}

# Helper to get the next available task ID
_get_next_task_id() {
  local task_file=$(_get_task_file_path)
  if [ -f "$task_file" ]; then
    # Get the max ID and add 1, or start from 1 if no tasks
    local max_id=$(awk -F' ' '{print $1}' "$task_file" 2>/dev/null | sort -nr | head -n 1)
    if [ -z "$max_id" ]; then
      echo 1
    else
      echo $((max_id + 1))
    fi
  else
    echo 1
  fi
}

# Helper to read tasks from the current workspace's task file
_read_tasks() {
  local task_file=$(_get_task_file_path)
  if [ -f "$task_file" ]; then
    cat "$task_file"
  else
    echo "" # Return empty string if file doesn't exist
  fi
}

# Helper to write tasks to the current workspace's task file
_write_tasks() {
  local task_file=$(_get_task_file_path)
  printf "%b" "$1" > "$task_file"
}

# Add a new task
add_task() {
  local description="$*"
  if [ -z "$description" ]; then
    read -p "Enter task description: " description
    if [ -z "$description" ]; then
      echo -e "${RED}Task description cannot be empty.${NC}" >&2
      return 1
    fi
  fi
  local task_id=$(_get_next_task_id)
  local new_task_line="$task_id todo $description"
  local current_tasks=$(_read_tasks)
  
  if [ -z "$current_tasks" ]; then
    _write_tasks "$new_task_line"
  else
    _write_tasks "$current_tasks\n$new_task_line"
  fi
  echo -e "${GREEN}Task added: $new_task_line${NC}"
}

# List tasks for the current workspace
list_tasks() {
  local task_file=$(_get_task_file_path)
  if [ -f "$task_file" ]; then
    printf "${BLUE}Tasks for %s (Workspace %s):${NC}\n" "$(get_current_workspace_name)" "$(get_workspace_name)"
    while IFS= read -r line; do
      local id=$(echo "$line" | awk '{print $1}')
      local status=$(echo "$line" | awk '{print $2}')
      local desc=$(echo "$line" | cut -d' ' -f3-)
      case "$status" in
        todo)
          echo -e "  ${YELLOW}[ ] ($id) $desc${NC}"
          ;;
        in_progress)
          echo -e "  ${CYAN}[>] ($id) $desc${NC}"
          ;;
        completed)
          echo -e "  ${GREEN}[x] ($id) $desc${NC}"
          ;;
      esac
    done <<< "$(_read_tasks)"
  else
    echo -e "${YELLOW}No tasks for $(get_current_workspace_name) (Workspace $(get_workspace_name)).${NC}"
  fi
}

# Helper to select a task using fzf
_fzf_task_selector() {
  local task_file=$(_get_task_file_path)
  if [ ! -f "$task_file" ] || [ -z "$(cat "$task_file")" ]; then
    echo -e "${YELLOW}No tasks to select.${NC}" >&2
    return 1
  fi

  local selected_task=$(cat "$task_file" | fzf --with-nth=3.. --delimiter=' ' --prompt="Select a task: ")
  if [ -n "$selected_task" ]; then
    echo "$(echo "$selected_task" | awk '{print $1}')"
  fi
}

# Update task status (in_progress or completed)
update_task_status() {
  local task_id="$1"
  local new_status="$2"
  if [ -z "$task_id" ]; then
    task_id=$(_fzf_task_selector)
    if [ -z "$task_id" ]; then
      return 1
    fi
  fi

  local updated=false
  local new_tasks_content=""
  while IFS= read -r line; do
    local id=$(echo "$line" | awk '{print $1}')
    if [ "$id" = "$task_id" ]; then
      local desc=$(echo "$line" | cut -d' ' -f3-)
      new_tasks_content+="$id $new_status $desc\n"
      updated=true
    else
      new_tasks_content+="$line\n"
    fi
  done <<< "$(_read_tasks)"

  if [ "$updated" = true ]; then
    _write_tasks "$(echo -e "$new_tasks_content" | sed 's/\n$//')"
    echo -e "${GREEN}Task $task_id marked as $new_status.${NC}"
  else
    echo -e "${RED}Task $task_id not found.${NC}" >&2
  fi
}

# Remove a task
remove_task() {
  local task_id="$1"
  if [ -z "$task_id" ]; then
    task_id=$(_fzf_task_selector)
    if [ -z "$task_id" ]; then
      return 1
    fi
  fi

  local removed=false
  local new_tasks_content=""
  while IFS= read -r line; do
    local id=$(echo "$line" | awk '{print $1}')
    if [ "$id" = "$task_id" ]; then
      removed=true
    else
      new_tasks_content+="$line\n"
    fi
  done <<< "$(_read_tasks)"

  if [ "$removed" = true ]; then
    _write_tasks "$(echo -e "$new_tasks_content" | sed 's/\n$//')"
    echo -e "${GREEN}Task $task_id removed.${NC}"
  else
    echo -e "${RED}Task $task_id not found.${NC}" >&2
  fi
}

# Main function
main() {
  if [ "$1" = "set" ]; then
    set_workspace_name "$2"
  elif [ "$1" = "get" ]; then
    get_current_workspace_name
  elif [ "$1" = "clear" ]; then
    clear_workspace_name
  elif [ "$1" = "switch" ]; then
    list_all_contexts
  elif [ "$1" = "current" ]; then
    shift # Remove 'current' from arguments
    if [ -z "$1" ]; then
      # No subcommand, show fzf menu
      local action=$(echo -e "Add Task\nList Tasks\nMark In Progress\nMark Complete\nRemove Task" | fzf --prompt="Select action: ")
      case "$action" in
        "Add Task")
          add_task
          ;;
        "List Tasks")
          list_tasks
          ;;
        "Mark In Progress")
          update_task_status "" "in_progress"
          ;;
        "Mark Complete")
          update_task_status "" "completed"
          ;;
        "Remove Task")
          remove_task
          ;;
        *)
          echo -e "${YELLOW}Action cancelled.${NC}" >&2
          ;;
      esac
    else
      # Subcommand provided
      case "$1" in
        add)
          shift # Remove 'add'
          add_task "$@"
          ;;
        list)
          list_tasks
          ;;
        progress)
          update_task_status "$2" "in_progress"
          ;;
        complete)
          update_task_status "$2" "completed"
          ;;
        remove)
          remove_task "$2"
          ;;
        *)
          echo -e "${RED}Usage: ctx current [add <description>|list|progress <task_id>|complete <task_id>|remove <task_id>]${NC}" >&2
          return 1
          ;;
      esac
    fi
  else
    echo -e "${RED}Usage: context [set|get|clear|switch] [name]${NC}"
    echo -e "${RED}       context current [add <description>|list|progress <task_id>|complete <task_id>|remove <task_id>]${NC}"
  fi
}

main "$@"
