#!/bin/bash

# Get the absolute path of the script's directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" &> /dev/null && pwd)"

# Use the script's directory as the base for the storage path
STORAGE_PATH="$SCRIPT_DIR/../../../.aerospace-context"
TASKS_STORAGE_PATH="$STORAGE_PATH/tasks"

# Ensure the storage directories exist
if [ ! -d "$STORAGE_PATH" ]; then
  mkdir -p "$STORAGE_PATH"
fi
if [ ! -d "$TASKS_STORAGE_PATH" ]; then
  mkdir -p "$TASKS_STORAGE_PATH"
fi

# Function to get the current workspace name
get_workspace_name() {
  aerospace list-workspaces --focused
}

# Function to set the name for the current workspace
set_workspace_name() {
  local workspace_name="$1"
  local current_workspace=$(get_workspace_name)
  echo "$workspace_name" > "$STORAGE_PATH/$current_workspace"
}

# Function to get the name of the current workspace
get_current_workspace_name() {
  local current_workspace=$(get_workspace_name)
  if [ -f "$STORAGE_PATH/$current_workspace" ]; then
    cat "$STORAGE_PATH/$current_workspace"
  else
    echo "(unnamed)"
  fi
}

# Function to clear the name for the current workspace
clear_workspace_name() {
  local current_workspace=$(get_workspace_name)
  if [ -f "$STORAGE_PATH/$current_workspace" ]; then
    rm "$STORAGE_PATH/$current_workspace"
  fi
}

# Function to list all saved contexts
list_all_contexts() {
  local contexts_list=""
  for file in "$STORAGE_PATH"/*; do
    if [ -f "$file" ]; then
      local workspace_id=$(basename "$file")
      local custom_name=$(cat "$file")
      contexts_list+="$workspace_id $custom_name\n"
    fi
  done

  if [ -n "$contexts_list" ]; then
    local selected_context=$(echo -e "$contexts_list" | fzf --with-nth=2.. --delimiter=' ')
    if [ -n "$selected_context" ]; then
      local selected_workspace_id=$(echo "$selected_context" | awk '{print $1}')
      aerospace workspace "$selected_workspace_id"
    fi
  else
    echo "No contexts saved." >&2
  fi
}

# --- Task Management Functions ---

# Helper to get the task file path for the current workspace
_get_task_file_path() {
  local current_workspace=$(get_workspace_name)
  echo "$TASKS_STORAGE_PATH/$current_workspace.tasks"
}

# Helper to get the next available task ID
_get_next_task_id() {
  local task_file=$(_get_task_file_path)
  if [ -f "$task_file" ]; then
    # Get the max ID and add 1, or start from 1 if no tasks
    local max_id=$(awk -F' ' '{print $1}' "$task_file" 2>/dev/null | sort -nr | head -n 1)
    if [ -z "$max_id" ]; then
      echo 1
    else
      echo $((max_id + 1))
    fi
  else
    echo 1
  fi
}

# Helper to read tasks from the current workspace's task file
_read_tasks() {
  local task_file=$(_get_task_file_path)
  if [ -f "$task_file" ]; then
    cat "$task_file"
  else
    echo "" # Return empty string if file doesn't exist
  fi
}

# Helper to write tasks to the current workspace's task file
_write_tasks() {
  local task_file=$(_get_task_file_path)
  echo -n "$1" > "$task_file"
}

# Add a new task
add_task() {
  local description="$*"
  if [ -z "$description" ]; then
    echo "Usage: ctx current add <description>" >&2
    return 1
  fi
  local task_id=$(_get_next_task_id)
  local new_task_line="$task_id todo $description"
  local current_tasks=$(_read_tasks)
  
  if [ -z "$current_tasks" ]; then
    _write_tasks "$new_task_line"
  else
    _write_tasks "$current_tasks\n$new_task_line"
  fi
  echo "Task added: $new_task_line"
}

# List tasks for the current workspace
list_tasks() {
  local task_file=$(_get_task_file_path)
  if [ -f "$task_file" ]; then
    echo "Tasks for $(get_current_workspace_name) (Workspace $(get_workspace_name)):
"
    while IFS= read -r line; do
      local id=$(echo "$line" | awk '{print $1}')
      local status=$(echo "$line" | awk '{print $2}')
      local desc=$(echo "$line" | cut -d' ' -f3-)
      case "$status" in
        todo)
          echo "  [ ] ($id) $desc"
          ;;
        in_progress)
          echo "  [>] ($id) $desc"
          ;;
        completed)
          echo "  [x] ($id) $desc"
          ;;
      esac
    done <<< "$(_read_tasks)"
  else
    echo "No tasks for $(get_current_workspace_name) (Workspace $(get_workspace_name))."
  fi
}

# Update task status (in_progress or completed)
update_task_status() {
  local task_id="$1"
  local new_status="$2"
  if [ -z "$task_id" ] || [ -z "$new_status" ]; then
    echo "Usage: ctx current [progress|complete] <task_id>" >&2
    return 1
  fi

  local updated=false
  local new_tasks_content=""
  while IFS= read -r line; do
    local id=$(echo "$line" | awk '{print $1}')
    if [ "$id" = "$task_id" ]; then
      local desc=$(echo "$line" | cut -d' ' -f3-)
      new_tasks_content+="$id $new_status $desc\n"
      updated=true
    else
      new_tasks_content+="$line\n"
    fi
  done <<< "$(_read_tasks)"

  if [ "$updated" = true ]; then
    _write_tasks "$(echo -e "$new_tasks_content" | sed 's/\n$//')"
    echo "Task $task_id marked as $new_status."
  else
    echo "Task $task_id not found." >&2
  fi
}

# Remove a task
remove_task() {
  local task_id="$1"
  if [ -z "$task_id" ]; then
    echo "Usage: ctx current remove <task_id>" >&2
    return 1
  fi

  local removed=false
  local new_tasks_content=""
  while IFS= read -r line; do
    local id=$(echo "$line" | awk '{print $1}')
    if [ "$id" = "$task_id" ]; then
      removed=true
    else
      new_tasks_content+="$line\n"
    fi
  done <<< "$(_read_tasks)"

  if [ "$removed" = true ]; then
    _write_tasks "$(echo -e "$new_tasks_content" | sed 's/\n$//')"
    echo "Task $task_id removed."
  else
    echo "Task $task_id not found." >&2
  fi
}

# Main function
main() {
  if [ "$1" = "set" ]; then
    set_workspace_name "$2"
  elif [ "$1" = "get" ]; then
    get_current_workspace_name
  elif [ "$1" = "clear" ]; then
    clear_workspace_name
  elif [ "$1" = "switch" ]; then
    list_all_contexts
  elif [ "$1" = "current" ]; then
    shift # Remove 'current' from arguments
    case "$1" in
      add)
        shift # Remove 'add'
        add_task "$@"
        ;;
      list)
        list_tasks
        ;;
      progress)
        update_task_status "$2" "in_progress"
        ;;
      complete)
        update_task_status "$2" "completed"
        ;;
      remove)
        remove_task "$2"
        ;;
      *)
        echo "Usage: ctx current [add <description>|list|progress <task_id>|complete <task_id>|remove <task_id>]" >&2
        return 1
        ;;
    esac
  else
    echo "Usage: context [set|get|clear|switch] [name]"
    echo "       context current [add <description>|list|progress <task_id>|complete <task_id>|remove <task_id>]"
  fi
}

main "$@"
